<?php
/* Что он выведет на каждом шаге? Почему? */
class A {

    function foo()
    {
        static $x = 0;
        echo ++$x;
    }
}

$a1 = new A();
$a2 = new A();
/*
 *      При компиляции скрипта класс вместе со своими полями и методами располагается в выделенной ему
 * области оперативной памяти. Когда объявлеястя экземпляр класса, ему также выделяется область в оперативной памяти,
 * однако полям память выделяется, а методам - нет. Таким образом, при обращении к
 * методу экземпляра выполняется метод класса - код метода не дублируется в экземпляр класса. На этапе компиляции
 * методу в качестве аргумента также передается $this, хотя мы этого явно не указываем.
 *
 *      Если в функции или методе класса объявляется переменная, ей выделяется память. После завершения работы функции
 * эта память высвобождается, т.е. переменная перестает существовать. А т.к. переменной выделяется заранее неизвестная
 * область памяти, то при каждом вызове функции все переменные в области видимости этой функции инициализируются заново.
 *
 *      Директива static у переменной внутри функции или метода указывает на то, что после выполнения этого метода
 * облать памяти, выделенная такой переменной не высвобождается. Таким образом, переменные static инициализируются только
 * один раз - при первом вызове функции/метода.
 *
 *      Исходя из изложенного, любой экземпляр класса, который обращается к методу класса выполняет не идентичный код,
 * а один и тот же! Если в это методе объявлена статическая переменная, то абсолютно неважно, какой из экземпляров
 * обратилсяе к этому методу - такая переменная указывает на одну и ту же область оперативной памяти.
 *
 *      Поэтому результат выполнения следующий:
*/
$a1->foo(); // = 1
$a2->foo(); // = 2
$a1->foo(); // = 3
$a2->foo(); // = 4


class A1 {

    function foo() {
        static $x = 0;
        echo ++$x;
    }
}
class B1 extends A1 {
}

$a1 = new A1();
$b1 = new B1();
/*
 *      При наследовании создается другой класс в отдельной области памяти. Т.е. все поля и методы,
 * которыми обладает родительский класс полностью копируются в область памяти создаваемого класса.
 *      Точнее, компилятор обнаружив выражение "class B1 extends A1", если не найдет одноименных методов
 * в классе B1, просто скопирует в этот класс соответствующий метод (компилятор вместо программиста заполняет класс, что
 * упрощает разработку и поддержание кода).
 * То есть, в данном случае, запись "class B1 extends A1{}" буквально означает следующее:
 * сlass B1 {
 *
 *   function foo() {
 *        static $x = 0;
 *        echo ++$x;
 *    }
 *  }
 *      И этот код полностью копируется в новую область памяти, на которую указывает класс B1. Соответственно в классах
 * A1 и B1 переменные $x будут указывать каждая - на свою область памяти
 *
 *      Поэтому, результат следующий:
 */
$a1->foo(); // = 1
$b1->foo(); // = 1
$a1->foo(); // = 2
$b1->foo(); // = 2


class A2 {

    public function foo() {
        static $x = 0;
        echo ++$x;
    }
}
class B2 extends A2 {
}

/*
 * Здесь все аналогично предыдущему варианту.
 * Конструкторы A2 и B2 не объявлены, поэтому (или в случае, если конструктор не имеет аргументов)
 * скобки при создании экземпляров этих классов можно опустить
 */
$a1 = new A2;
$b1 = new B2;
$a1->foo(); // = 1
$b1->foo(); // = 1
$a1->foo(); // = 2
$b1->foo(); // = 2